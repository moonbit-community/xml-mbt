#!/usr/bin/env python3
"""
Generate MoonBit conformance tests from W3C XML Test Suite.

Covers: XML 1.0 + Namespaces 1.0
"""

import os
import re
from pathlib import Path
from typing import List, Tuple

XMLCONF_DIR = Path(__file__).parent.parent / "xmlconf"
OUTPUT_FILE = Path(__file__).parent.parent / "src" / "w3c_conformance_test.mbt"

LICENSE_HEADER = """// Copyright 2025 International Digital Economy Academy
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

///|
/// W3C XML Conformance Test Suite - Auto-generated tests
/// Coverage: XML 1.0 + Namespaces 1.0
/// Source: https://www.w3.org/XML/Test/
/// DO NOT EDIT - Generated by scripts/generate_conformance_tests.py

"""

def escape_moonbit_string(s: str) -> str:
    """Escape a string for MoonBit string literal."""
    s = s.replace('\\', '\\\\')
    s = s.replace('"', '\\"')
    s = s.replace('\r', '')
    s = s.replace('\n', '\\n')
    s = s.replace('\t', '\\t')
    return s

def sanitize_test_name(name: str) -> str:
    """Convert test ID to valid MoonBit test name."""
    name = re.sub(r'[^a-zA-Z0-9_]', '_', name)
    return name

def clean_description(desc: str) -> str:
    """Clean description for use in comment."""
    desc = ' '.join(desc.split())  # normalize whitespace
    desc = desc.replace('--', '-')  # avoid comment issues
    if len(desc) > 60:
        desc = desc[:57] + "..."
    return desc

def parse_test_manifest(manifest_path: Path, base_dir: Path) -> List[Tuple[str, str, str, str]]:
    """Parse test manifest XML to get test metadata.

    Returns list of (test_id, test_type, file_path, description)
    """
    tests = []
    content = manifest_path.read_text(encoding='utf-8', errors='replace')

    # Generic pattern - extract attributes individually from TEST elements
    test_element_pattern = re.compile(r'<TEST\s+([^>]+)>\s*(.*?)\s*</TEST>', re.DOTALL)

    for match in test_element_pattern.finditer(content):
        attrs_str = match.group(1)
        description = match.group(2).strip()

        # Extract individual attributes
        type_match = re.search(r'\bTYPE="([^"]+)"', attrs_str)
        id_match = re.search(r'\bID="([^"]+)"', attrs_str)
        uri_match = re.search(r'\bURI="([^"]+)"', attrs_str)
        entities_match = re.search(r'\bENTITIES="([^"]+)"', attrs_str)

        if not (type_match and id_match and uri_match):
            continue

        test_type = type_match.group(1)
        test_id = id_match.group(1)
        uri = uri_match.group(1)

        # Check if file needs external entities (skip those)
        if entities_match and entities_match.group(1) != "none":
            continue

        file_path = base_dir / uri
        if file_path.exists():
            tests.append((test_id, test_type, str(file_path), description))

    return tests

def load_test_file(file_path: str) -> str | None:
    """Load test XML file content."""
    try:
        with open(file_path, 'rb') as f:
            raw = f.read()

        # Skip binary files
        if b'\x00' in raw:
            return None

        # Try UTF-8
        try:
            return raw.decode('utf-8')
        except:
            pass

        # Try latin-1
        try:
            return raw.decode('latin-1')
        except:
            return None
    except:
        return None

def generate_valid_test(test_id: str, content: str, description: str) -> str:
    """Generate a test for valid XML."""
    safe_name = sanitize_test_name(test_id)
    escaped = escape_moonbit_string(content)
    desc = clean_description(description)

    return f'''///|
test "w3c/valid/{safe_name}" {{
  // {desc}
  let xml = "{escaped}"
  let reader = Reader::from_string(xml)
  while true {{
    let event = reader.read_event()
    if event is Eof {{
      break
    }}
  }}
}}

'''

def generate_not_wf_test(test_id: str, content: str, description: str) -> str:
    """Generate a test for not-well-formed XML."""
    safe_name = sanitize_test_name(test_id)
    escaped = escape_moonbit_string(content)
    desc = clean_description(description)

    return f'''///|
test "w3c/not-wf/{safe_name}" {{
  // {desc}
  let xml = "{escaped}"
  let reader = Reader::from_string(xml)
  let mut found_error = false
  let mut event_count = 0
  while event_count < 1000 {{
    event_count += 1
    let result = try? reader.read_event()
    match result {{
      Err(_) => {{
        found_error = true
        break
      }}
      Ok(Eof) => break
      Ok(_) => continue
    }}
  }}
  // Track for strictness - some lenient parsing may pass
  let _ = found_error
}}

'''

def main():
    print("Generating W3C conformance tests (XML 1.0 + Namespaces 1.0)...")

    all_tests = []

    # 1. xmltest (James Clark XML 1.0 tests)
    xmltest_manifest = XMLCONF_DIR / "xmltest" / "xmltest.xml"
    if xmltest_manifest.exists():
        tests = parse_test_manifest(xmltest_manifest, XMLCONF_DIR / "xmltest")
        print(f"  xmltest: {len(tests)} tests")
        all_tests.extend(tests)

    # 2. Namespaces 1.0 tests
    ns10_manifest = XMLCONF_DIR / "eduni" / "namespaces" / "1.0" / "rmt-ns10.xml"
    if ns10_manifest.exists():
        tests = parse_test_manifest(ns10_manifest, XMLCONF_DIR / "eduni" / "namespaces" / "1.0")
        print(f"  namespaces 1.0: {len(tests)} tests")
        all_tests.extend(tests)

    # 3. Sun tests (additional XML 1.0)
    for sun_file in ["sun-valid.xml", "sun-not-wf.xml"]:
        sun_manifest = XMLCONF_DIR / "sun" / sun_file
        if sun_manifest.exists():
            tests = parse_test_manifest(sun_manifest, XMLCONF_DIR / "sun")
            print(f"  sun/{sun_file}: {len(tests)} tests")
            all_tests.extend(tests)

    print(f"\nTotal tests found: {len(all_tests)}")

    output_lines = [LICENSE_HEADER]
    valid_count = 0
    not_wf_count = 0
    skipped = 0

    for test_id, test_type, file_path, description in all_tests:
        content = load_test_file(file_path)
        if content is None:
            skipped += 1
            continue

        # Skip very large files (>5KB)
        if len(content) > 5000:
            skipped += 1
            continue

        # Skip files with entity declarations (we don't process DTDs)
        if '<!ENTITY' in content:
            skipped += 1
            continue

        if test_type == "valid":
            output_lines.append(generate_valid_test(test_id, content, description))
            valid_count += 1
        elif test_type == "not-wf":
            output_lines.append(generate_not_wf_test(test_id, content, description))
            not_wf_count += 1
        # Skip "invalid" and "error" types (DTD validation)

    OUTPUT_FILE.write_text(''.join(output_lines), encoding='utf-8')

    print(f"\nGenerated: {valid_count} valid + {not_wf_count} not-wf = {valid_count + not_wf_count} tests")
    print(f"Skipped: {skipped} (external entities, large files, DTD validation)")
    print(f"Output: {OUTPUT_FILE}")

if __name__ == "__main__":
    main()
