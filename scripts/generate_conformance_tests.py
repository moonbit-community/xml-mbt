#!/usr/bin/env python3
"""
Generate MoonBit conformance tests from W3C XML Test Suite.

Covers: XML 1.0 + Namespaces 1.0

Uses libxml2 (xmllint) for well-formedness checking.
Run `moon test --update` after generation to populate expected values.
"""

import os
import re
import subprocess
import sys
from pathlib import Path
from typing import List, Tuple

XMLCONF_DIR = Path(__file__).parent.parent / "xmlconf"
OUTPUT_FILE = Path(__file__).parent.parent / "src" / "w3c_conformance_test.mbt"

LICENSE_HEADER = """// ============================================================================
// AUTO-GENERATED FILE - DO NOT MODIFY MANUALLY
// Generated by: scripts/generate_conformance_tests.py
// Regenerate with: python3 scripts/generate_conformance_tests.py
// ============================================================================

// Copyright 2025 International Digital Economy Academy
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

///|
/// W3C XML Conformance Test Suite - Auto-generated tests
/// Coverage: XML 1.0 + Namespaces 1.0
/// Source: https://www.w3.org/XML/Test/

"""

def escape_moonbit_string(s: str) -> str:
    """Escape a string for MoonBit string literal."""
    s = s.replace('\\', '\\\\')
    s = s.replace('"', '\\"')
    s = s.replace('\r', '')
    s = s.replace('\n', '\\n')
    s = s.replace('\t', '\\t')
    return s

def sanitize_test_name(name: str) -> str:
    """Convert test ID to valid MoonBit test name."""
    name = re.sub(r'[^a-zA-Z0-9_]', '_', name)
    return name

def clean_description(desc: str) -> str:
    """Clean description for use in comment."""
    desc = ' '.join(desc.split())  # normalize whitespace
    desc = desc.replace('--', '-')  # avoid comment issues
    if len(desc) > 60:
        desc = desc[:57] + "..."
    return desc

def parse_test_manifest(manifest_path: Path, base_dir: Path) -> List[Tuple[str, str, str, str]]:
    """Parse test manifest XML to get test metadata.

    Returns list of (test_id, test_type, file_path, description)
    """
    tests = []
    content = manifest_path.read_text(encoding='utf-8', errors='replace')

    # Generic pattern - extract attributes individually from TEST elements
    test_element_pattern = re.compile(r'<TEST\s+([^>]+)>\s*(.*?)\s*</TEST>', re.DOTALL)

    for match in test_element_pattern.finditer(content):
        attrs_str = match.group(1)
        description = match.group(2).strip()

        # Extract individual attributes
        type_match = re.search(r'\bTYPE="([^"]+)"', attrs_str)
        id_match = re.search(r'\bID="([^"]+)"', attrs_str)
        uri_match = re.search(r'\bURI="([^"]+)"', attrs_str)
        entities_match = re.search(r'\bENTITIES="([^"]+)"', attrs_str)

        if not (type_match and id_match and uri_match):
            continue

        test_type = type_match.group(1)
        test_id = id_match.group(1)
        uri = uri_match.group(1)

        # Check if file needs external entities (skip those)
        if entities_match and entities_match.group(1) != "none":
            continue

        file_path = base_dir / uri
        if file_path.exists():
            tests.append((test_id, test_type, str(file_path), description))

    return tests

def check_well_formed(xml_content: str) -> bool:
    """Check if XML is well-formed using libxml2 (xmllint)."""
    try:
        result = subprocess.run(
            ['xmllint', '--noout', '-'],
            input=xml_content,
            capture_output=True,
            text=True,
            timeout=5
        )
        return result.returncode == 0
    except Exception:
        # If xmllint fails or not available, assume not well-formed for not-wf tests
        return False

def load_test_file(file_path: str) -> str | None:
    """Load test XML file content."""
    try:
        with open(file_path, 'rb') as f:
            raw = f.read()

        # Skip binary files
        if b'\x00' in raw:
            return None

        # Try UTF-8
        try:
            return raw.decode('utf-8')
        except:
            pass

        # Try latin-1
        try:
            return raw.decode('latin-1')
        except:
            return None
    except:
        return None

def generate_valid_test(test_id: str, content: str, description: str) -> str:
    """Generate a test for valid XML with snapshot testing."""
    safe_name = sanitize_test_name(test_id)
    escaped = escape_moonbit_string(content)
    desc = clean_description(description)

    # Generate test without expected value - use `moon test --update` to fill
    return f'''///|
test "w3c/valid/{safe_name}" {{
  // {desc}
  let xml = "{escaped}"
  let reader = Reader::from_string(xml)
  let events : Array[Event] = []
  while true {{
    let event = reader.read_event()
    events.push(event)
    if event is Eof {{
      break
    }}
  }}
  inspect(events)
}}

'''

def generate_not_wf_test(test_id: str, content: str, description: str, expects_error: bool) -> str:
    """Generate a test for not-well-formed XML.

    If libxml2 rejects it, verify our parser also errors.
    If libxml2 accepts it (lenient), use snapshot testing.
    """
    safe_name = sanitize_test_name(test_id)
    escaped = escape_moonbit_string(content)
    desc = clean_description(description)

    if expects_error:
        # libxml2 rejected this, verify we also error
        return f'''///|
test "w3c/not-wf/{safe_name}" {{
  // {desc}
  let xml = "{escaped}"
  let reader = Reader::from_string(xml)
  let mut has_error = false
  for i = 0; i < 1000 && not(has_error); i = i + 1 {{
    try reader.read_event() catch {{ _ => has_error = true }} noraise {{ Eof => break; _ => continue }}
  }}
  inspect(has_error, content="true")
}}

'''
    else:
        # libxml2 parsed this (lenient), use snapshot testing
        return f'''///|
test "w3c/not-wf/{safe_name}" {{
  // {desc} (parser is lenient)
  let xml = "{escaped}"
  let reader = Reader::from_string(xml)
  let events : Array[Event] = []
  while true {{
    let event = reader.read_event()
    events.push(event)
    if event is Eof {{
      break
    }}
  }}
  inspect(events)
}}

'''

def main():
    print("Generating W3C conformance tests (XML 1.0 + Namespaces 1.0)...")

    # Check if xmllint is available
    try:
        result = subprocess.run(['xmllint', '--version'], capture_output=True, text=True)
        print(f"Using libxml2 for well-formedness checking")
    except FileNotFoundError:
        print("Error: xmllint not found. Please install libxml2.")
        sys.exit(1)

    all_tests = []

    # 1. xmltest (James Clark XML 1.0 tests)
    xmltest_manifest = XMLCONF_DIR / "xmltest" / "xmltest.xml"
    if xmltest_manifest.exists():
        tests = parse_test_manifest(xmltest_manifest, XMLCONF_DIR / "xmltest")
        print(f"  xmltest: {len(tests)} tests")
        all_tests.extend(tests)

    # 2. Namespaces 1.0 tests
    ns10_manifest = XMLCONF_DIR / "eduni" / "namespaces" / "1.0" / "rmt-ns10.xml"
    if ns10_manifest.exists():
        tests = parse_test_manifest(ns10_manifest, XMLCONF_DIR / "eduni" / "namespaces" / "1.0")
        print(f"  namespaces 1.0: {len(tests)} tests")
        all_tests.extend(tests)

    # 3. Sun tests (additional XML 1.0)
    for sun_file in ["sun-valid.xml", "sun-not-wf.xml"]:
        sun_manifest = XMLCONF_DIR / "sun" / sun_file
        if sun_manifest.exists():
            tests = parse_test_manifest(sun_manifest, XMLCONF_DIR / "sun")
            print(f"  sun/{sun_file}: {len(tests)} tests")
            all_tests.extend(tests)

    # 4. Errata tests (XML 1.0 errata editions)
    errata_dirs = [
        ("eduni/errata-2e", "errata2e.xml"),
        ("eduni/errata-3e", "errata3e.xml"),
        ("eduni/errata-4e", "errata4e.xml"),
    ]
    for errata_dir, manifest_name in errata_dirs:
        manifest = XMLCONF_DIR / errata_dir / manifest_name
        if manifest.exists():
            tests = parse_test_manifest(manifest, XMLCONF_DIR / errata_dir)
            print(f"  {errata_dir}: {len(tests)} tests")
            all_tests.extend(tests)

    # 5. Misc tests
    misc_manifest = XMLCONF_DIR / "eduni" / "misc" / "ht-bh.xml"
    if misc_manifest.exists():
        tests = parse_test_manifest(misc_manifest, XMLCONF_DIR / "eduni" / "misc")
        print(f"  eduni/misc: {len(tests)} tests")
        all_tests.extend(tests)

    print(f"\nTotal tests found: {len(all_tests)}")

    output_lines = [LICENSE_HEADER]
    valid_count = 0
    not_wf_count = 0
    skipped = 0

    for test_id, test_type, file_path, description in all_tests:
        content = load_test_file(file_path)
        if content is None:
            skipped += 1
            continue

        # Skip very large files (>50KB)
        if len(content) > 50000:
            skipped += 1
            continue

        # Skip files with external entity references (SYSTEM/PUBLIC)
        if '<!ENTITY' in content and ('SYSTEM' in content or 'PUBLIC' in content):
            skipped += 1
            continue

        # Skip XML 1.1 documents (we only support XML 1.0)
        if 'version="1.1"' in content or "version='1.1'" in content:
            skipped += 1
            continue

        if test_type == "valid":
            output_lines.append(generate_valid_test(test_id, content, description))
            valid_count += 1
        elif test_type == "not-wf":
            # Check if libxml2 considers it well-formed
            normalized_content = content.replace('\r\n', '\n').replace('\r', '\n')
            is_well_formed = check_well_formed(normalized_content)
            output_lines.append(generate_not_wf_test(test_id, content, description, expects_error=not is_well_formed))
            not_wf_count += 1
        # Skip "invalid" and "error" types (DTD validation)

    OUTPUT_FILE.write_text(''.join(output_lines), encoding='utf-8')

    print(f"\nGenerated: {valid_count} valid + {not_wf_count} not-wf = {valid_count + not_wf_count} tests")
    print(f"Skipped: {skipped} (external entities, large files, DTD validation)")
    print(f"Output: {OUTPUT_FILE}")
    print(f"\nRun 'moon test --update' to populate expected values")

if __name__ == "__main__":
    main()
