#!/usr/bin/env python3
"""
Generate MoonBit conformance tests from W3C XML Test Suite.

Covers: XML 1.0 + Namespaces 1.0

Uses xml_reference.py (lxml) to generate expected event sequences.
Tests filter events to handle known differences between our parser and lxml.
"""

import re
import subprocess
import sys
from pathlib import Path
from typing import List, Tuple, Optional

# Import the reference parser
from xml_reference import parse_xml, escape_for_debug

XMLCONF_DIR = Path(__file__).parent.parent / "xmlconf"
OUTPUT_FILE = Path(__file__).parent.parent / "src" / "w3c_conformance_test.mbt"

LICENSE_HEADER = """// ============================================================================
// AUTO-GENERATED FILE - DO NOT MODIFY MANUALLY
// Generated by: scripts/generate_conformance_tests.py
// Regenerate with: python3 scripts/generate_conformance_tests.py
// ============================================================================

// Copyright 2025 International Digital Economy Academy
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

///|
/// W3C XML Conformance Test Suite - Auto-generated tests
/// Coverage: XML 1.0 + Namespaces 1.0
/// Source: https://www.w3.org/XML/Test/

"""

def escape_moonbit_string(s: str) -> str:
    """Escape a string for MoonBit string literal."""
    s = s.replace('\\', '\\\\')
    s = s.replace('"', '\\"')
    s = s.replace('\r', '')
    s = s.replace('\n', '\\n')
    s = s.replace('\t', '\\t')
    return s

def sanitize_test_name(name: str) -> str:
    """Convert test ID to valid MoonBit test name."""
    name = re.sub(r'[^a-zA-Z0-9_]', '_', name)
    return name

def clean_description(desc: str) -> str:
    """Clean description for use in comment."""
    desc = ' '.join(desc.split())
    desc = desc.replace('--', '-')
    if len(desc) > 60:
        desc = desc[:57] + "..."
    return desc

def parse_test_manifest(manifest_path: Path, base_dir: Path) -> List[Tuple[str, str, str, str]]:
    """Parse test manifest XML to get test metadata."""
    tests = []
    content = manifest_path.read_text(encoding='utf-8', errors='replace')
    test_element_pattern = re.compile(r'<TEST\s+([^>]+)>\s*(.*?)\s*</TEST>', re.DOTALL)

    for match in test_element_pattern.finditer(content):
        attrs_str = match.group(1)
        description = match.group(2).strip()

        type_match = re.search(r'\bTYPE="([^"]+)"', attrs_str)
        id_match = re.search(r'\bID="([^"]+)"', attrs_str)
        uri_match = re.search(r'\bURI="([^"]+)"', attrs_str)
        entities_match = re.search(r'\bENTITIES="([^"]+)"', attrs_str)

        if not (type_match and id_match and uri_match):
            continue

        test_type = type_match.group(1)
        test_id = id_match.group(1)
        uri = uri_match.group(1)

        if entities_match and entities_match.group(1) != "none":
            continue

        file_path = base_dir / uri
        if file_path.exists():
            tests.append((test_id, test_type, str(file_path), description))

    return tests

def check_well_formed_libxml(xml_content: str) -> bool:
    """Check if XML is well-formed using libxml2 (xmllint)."""
    try:
        result = subprocess.run(
            ['xmllint', '--noout', '-'],
            input=xml_content,
            capture_output=True,
            text=True,
            timeout=5
        )
        return result.returncode == 0
    except Exception:
        return False

def load_test_file(file_path: str) -> Optional[str]:
    """Load test XML file content."""
    try:
        with open(file_path, 'rb') as f:
            raw = f.read()

        if b'\x00' in raw:
            return None

        try:
            return raw.decode('utf-8')
        except:
            pass

        try:
            return raw.decode('latin-1')
        except:
            return None
    except:
        return None

def get_expected_events(content: str) -> Optional[str]:
    """Get expected events from reference parser."""
    try:
        success, result = parse_xml(content)
        if success:
            return result
        return None
    except Exception as e:
        return None

def generate_valid_test_with_events(test_id: str, content: str, description: str, expected_events: str) -> str:
    """Generate a test for valid XML with expected event sequence."""
    safe_name = sanitize_test_name(test_id)
    escaped = escape_moonbit_string(content)
    desc = clean_description(description)
    # Escape the expected events string for use inside a MoonBit string literal
    escaped_events = escape_moonbit_string(expected_events)

    return f'''///|
test "w3c/valid/{safe_name}" {{
  // {desc}
  let xml = "{escaped}"
  let reader = Reader::from_string(xml)
  let events = reader.read_events_until_eof()
  inspect(to_libxml_format(events), content="{escaped_events}")
}}

'''

def generate_valid_test_error_only(test_id: str, content: str, description: str) -> str:
    """Generate a test for valid XML - only verify no error (fallback)."""
    safe_name = sanitize_test_name(test_id)
    escaped = escape_moonbit_string(content)
    desc = clean_description(description)

    return f'''///|
test "w3c/valid/{safe_name}" {{
  // {desc}
  let xml = "{escaped}"
  let reader = Reader::from_string(xml)
  // Verify parsing succeeds
  let events = reader.read_events_until_eof()
  assert_true(events.length() > 0)
}}

'''

def generate_not_wf_test(test_id: str, content: str, description: str, expects_error: bool) -> str:
    """Generate a test for not-well-formed XML."""
    safe_name = sanitize_test_name(test_id)
    escaped = escape_moonbit_string(content)
    desc = clean_description(description)
    expected = "true" if expects_error else "false"
    suffix = "" if expects_error else " (parser is lenient)"

    return f'''///|
test "w3c/not-wf/{safe_name}" {{
  // {desc}{suffix}
  let xml = "{escaped}"
  let reader = Reader::from_string(xml)
  let has_error = (try? reader.read_events_until_eof()) is Err(_)
  assert_true(has_error)
}}

'''

def main():
    print("Generating W3C conformance tests (XML 1.0 + Namespaces 1.0)...")
    print("Phase 1: Collecting tests...")

    try:
        subprocess.run(['xmllint', '--version'], capture_output=True, text=True)
    except FileNotFoundError:
        print("Error: xmllint not found. Please install libxml2.")
        sys.exit(1)

    all_tests = []

    manifests = [
        (XMLCONF_DIR / "xmltest" / "xmltest.xml", XMLCONF_DIR / "xmltest"),
        (XMLCONF_DIR / "eduni" / "namespaces" / "1.0" / "rmt-ns10.xml", XMLCONF_DIR / "eduni" / "namespaces" / "1.0"),
        (XMLCONF_DIR / "sun" / "sun-valid.xml", XMLCONF_DIR / "sun"),
        (XMLCONF_DIR / "sun" / "sun-not-wf.xml", XMLCONF_DIR / "sun"),
        (XMLCONF_DIR / "eduni" / "errata-2e" / "errata2e.xml", XMLCONF_DIR / "eduni" / "errata-2e"),
        (XMLCONF_DIR / "eduni" / "errata-3e" / "errata3e.xml", XMLCONF_DIR / "eduni" / "errata-3e"),
        (XMLCONF_DIR / "eduni" / "errata-4e" / "errata4e.xml", XMLCONF_DIR / "eduni" / "errata-4e"),
        (XMLCONF_DIR / "eduni" / "misc" / "ht-bh.xml", XMLCONF_DIR / "eduni" / "misc"),
    ]

    for manifest, base_dir in manifests:
        if manifest.exists():
            tests = parse_test_manifest(manifest, base_dir)
            print(f"  {manifest.relative_to(XMLCONF_DIR)}: {len(tests)} tests")
            all_tests.extend(tests)

    print(f"\nTotal tests found: {len(all_tests)}")

    # Collect test cases
    valid_tests = []
    not_wf_tests = []
    skipped = 0
    skipped_reasons = {
        'encoding': 0,
        'large': 0,
        'external_entity': 0,
        'xml11': 0,
        'libxml_accepts': 0,
        'reference_failed': 0,
    }

    print("\nPhase 2: Processing tests and generating expected events...")

    for i, (test_id, test_type, file_path, description) in enumerate(all_tests):
        if (i + 1) % 100 == 0:
            print(f"  Processing {i + 1}/{len(all_tests)}...")

        content = load_test_file(file_path)
        if content is None:
            skipped += 1
            skipped_reasons['encoding'] += 1
            continue

        if len(content) > 50000:
            skipped += 1
            skipped_reasons['large'] += 1
            continue

        if '<!ENTITY' in content and ('SYSTEM' in content or 'PUBLIC' in content):
            skipped += 1
            skipped_reasons['external_entity'] += 1
            continue

        if 'version="1.1"' in content or "version='1.1'" in content:
            skipped += 1
            skipped_reasons['xml11'] += 1
            continue

        normalized = content.replace('\r\n', '\n').replace('\r', '\n')

        if test_type == "valid":
            # Get expected events from reference parser
            expected_events = get_expected_events(normalized)
            if expected_events:
                valid_tests.append((test_id, content, description, expected_events))
            else:
                # Fallback: reference parser failed, just check no error
                skipped_reasons['reference_failed'] += 1
                valid_tests.append((test_id, content, description, None))
        elif test_type == "not-wf":
            libxml_ok = check_well_formed_libxml(normalized)
            if not libxml_ok:
                not_wf_tests.append((test_id, content, description, True))
            else:
                # libxml2 accepts - skip (both are lenient)
                skipped += 1
                skipped_reasons['libxml_accepts'] += 1

    print(f"\nPhase 3: Generating test file...")

    # Generate output
    output_lines = [LICENSE_HEADER]

    valid_with_events = 0
    valid_error_only = 0
    for test_id, content, description, expected_events in valid_tests:
        if expected_events:
            output_lines.append(generate_valid_test_with_events(test_id, content, description, expected_events))
            valid_with_events += 1
        else:
            output_lines.append(generate_valid_test_error_only(test_id, content, description))
            valid_error_only += 1

    for test_id, content, description, expects_error in not_wf_tests:
        output_lines.append(generate_not_wf_test(test_id, content, description, expects_error))

    OUTPUT_FILE.write_text(''.join(output_lines), encoding='utf-8')

    print(f"\nGenerated:")
    print(f"  Valid tests with expected events: {valid_with_events}")
    print(f"  Valid tests (error-only check):   {valid_error_only}")
    print(f"  Not-well-formed tests:            {len(not_wf_tests)}")
    print(f"  Total:                            {valid_with_events + valid_error_only + len(not_wf_tests)}")
    print(f"\nSkipped: {skipped}")
    for reason, count in skipped_reasons.items():
        if count > 0:
            print(f"  {reason}: {count}")
    print(f"\nOutput: {OUTPUT_FILE}")

    # Format the generated file
    print("\nFormatting generated file...")
    try:
        subprocess.run(['moon', 'fmt', str(OUTPUT_FILE)], check=True)
        print("Formatted successfully.")
    except subprocess.CalledProcessError:
        print("Warning: moon fmt failed")
    except FileNotFoundError:
        print("Warning: moon not found, skipping format")

if __name__ == "__main__":
    main()
