#!/usr/bin/env python3
"""
Generate MoonBit conformance tests from W3C XML Test Suite.

Covers: XML 1.0 + Namespaces 1.0

Uses quick-xml (Rust) as the reference implementation to generate expected snapshots.
"""

import json
import os
import re
import subprocess
import sys
from pathlib import Path
from typing import List, Tuple, Optional

XMLCONF_DIR = Path(__file__).parent.parent / "xmlconf"
OUTPUT_FILE = Path(__file__).parent.parent / "src" / "w3c_conformance_test.mbt"
QUICKXML_REF = Path(__file__).parent.parent / "tools" / "quickxml-ref" / "target" / "release" / "quickxml-ref"

LICENSE_HEADER = """// ============================================================================
// AUTO-GENERATED FILE - DO NOT MODIFY MANUALLY
// Generated by: scripts/generate_conformance_tests.py
// Regenerate with: python3 scripts/generate_conformance_tests.py
// ============================================================================

// Copyright 2025 International Digital Economy Academy
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

///|
/// W3C XML Conformance Test Suite - Auto-generated tests
/// Coverage: XML 1.0 + Namespaces 1.0
/// Source: https://www.w3.org/XML/Test/

"""

def escape_moonbit_string(s: str) -> str:
    """Escape a string for MoonBit string literal."""
    s = s.replace('\\', '\\\\')
    s = s.replace('"', '\\"')
    s = s.replace('\r', '')
    s = s.replace('\n', '\\n')
    s = s.replace('\t', '\\t')
    return s

def escape_control_chars_for_debug(s: str) -> str:
    """Escape control characters to match MoonBit's Debug format.

    MoonBit escapes control characters as \\u{XX} in Debug output,
    so we need to convert raw control chars in quick-xml output.
    """
    result = []
    for c in s:
        code = ord(c)
        # Escape C0 control characters (except common ones already handled)
        if code < 0x20 and c not in '\t\n\r':
            result.append(f'\\u{{{code:02x}}}')
        # Escape DEL
        elif code == 0x7F:
            result.append('\\u{7f}')
        # Escape C1 control characters
        elif 0x80 <= code <= 0x9F:
            result.append(f'\\u{{{code:02x}}}')
        else:
            result.append(c)
    return ''.join(result)

def sanitize_test_name(name: str) -> str:
    """Convert test ID to valid MoonBit test name."""
    name = re.sub(r'[^a-zA-Z0-9_]', '_', name)
    return name

def clean_description(desc: str) -> str:
    """Clean description for use in comment."""
    desc = ' '.join(desc.split())  # normalize whitespace
    desc = desc.replace('--', '-')  # avoid comment issues
    if len(desc) > 60:
        desc = desc[:57] + "..."
    return desc

def parse_test_manifest(manifest_path: Path, base_dir: Path) -> List[Tuple[str, str, str, str]]:
    """Parse test manifest XML to get test metadata.

    Returns list of (test_id, test_type, file_path, description)
    """
    tests = []
    content = manifest_path.read_text(encoding='utf-8', errors='replace')

    # Generic pattern - extract attributes individually from TEST elements
    test_element_pattern = re.compile(r'<TEST\s+([^>]+)>\s*(.*?)\s*</TEST>', re.DOTALL)

    for match in test_element_pattern.finditer(content):
        attrs_str = match.group(1)
        description = match.group(2).strip()

        # Extract individual attributes
        type_match = re.search(r'\bTYPE="([^"]+)"', attrs_str)
        id_match = re.search(r'\bID="([^"]+)"', attrs_str)
        uri_match = re.search(r'\bURI="([^"]+)"', attrs_str)
        entities_match = re.search(r'\bENTITIES="([^"]+)"', attrs_str)

        if not (type_match and id_match and uri_match):
            continue

        test_type = type_match.group(1)
        test_id = id_match.group(1)
        uri = uri_match.group(1)

        # Check if file needs external entities (skip those)
        if entities_match and entities_match.group(1) != "none":
            continue

        file_path = base_dir / uri
        if file_path.exists():
            tests.append((test_id, test_type, str(file_path), description))

    return tests

class QuickXmlRef:
    """Interface to quick-xml reference tool."""

    def __init__(self):
        self.proc = None

    def start(self):
        if not QUICKXML_REF.exists():
            print(f"Warning: quick-xml reference tool not found at {QUICKXML_REF}")
            print("Run: cargo build --release --manifest-path tools/quickxml-ref/Cargo.toml")
            return False
        self.proc = subprocess.Popen(
            [str(QUICKXML_REF)],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            text=True
        )
        return True

    def parse(self, xml: str) -> Optional[str]:
        """Parse XML and return expected events string."""
        if not self.proc:
            return None
        try:
            # Send XML as single line (escape newlines)
            escaped = xml.replace('\\', '\\\\').replace('\n', '\\n').replace('\r', '\\r')
            self.proc.stdin.write(escaped + "\n")
            self.proc.stdin.flush()
            # Use select with timeout to avoid hanging
            import select
            ready, _, _ = select.select([self.proc.stdout], [], [], 5.0)
            if ready:
                return self.proc.stdout.readline().strip()
            else:
                print(f"  Warning: quick-xml timeout, restarting process...")
                self.stop()
                self.start()
                return None
        except Exception as e:
            print(f"  Warning: quick-xml error: {e}")
            return None

    def stop(self):
        if self.proc:
            self.proc.stdin.close()
            self.proc.wait()

quickxml = QuickXmlRef()

def load_test_file(file_path: str) -> str | None:
    """Load test XML file content."""
    try:
        with open(file_path, 'rb') as f:
            raw = f.read()

        # Skip binary files
        if b'\x00' in raw:
            return None

        # Try UTF-8
        try:
            return raw.decode('utf-8')
        except:
            pass

        # Try latin-1
        try:
            return raw.decode('latin-1')
        except:
            return None
    except:
        return None

def generate_valid_test(test_id: str, content: str, description: str, expected: Optional[str]) -> str:
    """Generate a test for valid XML with snapshot testing."""
    safe_name = sanitize_test_name(test_id)
    escaped = escape_moonbit_string(content)
    desc = clean_description(description)

    if expected:
        # Escape control characters to match MoonBit's Debug format
        expected_escaped = escape_control_chars_for_debug(expected)
        # Use expected value from quick-xml with #| multi-line string (no escaping needed)
        return f'''///|
test "w3c/valid/{safe_name}" {{
  // {desc}
  let xml = "{escaped}"
  let reader = Reader::from_string(xml)
  let events : Array[Event] = []
  while true {{
    let event = reader.read_event()
    events.push(event)
    if event is Eof {{
      break
    }}
  }}
  inspect(events, content=(
    #|{expected_escaped}
  ))
}}

'''
    else:
        # No expected value, let moon test --update fill it
        return f'''///|
test "w3c/valid/{safe_name}" {{
  // {desc}
  let xml = "{escaped}"
  let reader = Reader::from_string(xml)
  let events : Array[Event] = []
  while true {{
    let event = reader.read_event()
    events.push(event)
    if event is Eof {{
      break
    }}
  }}
  inspect(events)
}}

'''

def generate_not_wf_test(test_id: str, content: str, description: str, quickxml_errors: bool, expected: Optional[str]) -> str:
    """Generate a test for not-well-formed XML.

    If quick-xml errors, verify our parser also errors.
    If quick-xml succeeds, use its output as expected (both parsers are lenient).
    """
    safe_name = sanitize_test_name(test_id)
    escaped = escape_moonbit_string(content)
    desc = clean_description(description)

    if quickxml_errors:
        # Quick-xml rejected this, verify we also error
        return f'''///|
test "w3c/not-wf/{safe_name}" {{
  // {desc}
  let xml = "{escaped}"
  let reader = Reader::from_string(xml)
  let mut has_error = false
  for i = 0; i < 1000 && not(has_error); i = i + 1 {{
    match (try? reader.read_event()) {{
      Err(_) => has_error = true
      Ok(Eof) => break
      Ok(_) => continue
    }}
  }}
  inspect(has_error, content="true")
}}

'''
    else:
        # Quick-xml parsed this (lenient), so should we - use same format as valid tests
        # Escape control characters to match MoonBit's Debug format
        expected_escaped = escape_control_chars_for_debug(expected) if expected else ""
        return f'''///|
test "w3c/not-wf/{safe_name}" {{
  // {desc} (parser is lenient like quick-xml)
  let xml = "{escaped}"
  let reader = Reader::from_string(xml)
  let events : Array[Event] = []
  while true {{
    let event = reader.read_event()
    events.push(event)
    if event is Eof {{
      break
    }}
  }}
  inspect(events, content=(
    #|{expected_escaped}
  ))
}}

'''

def main():
    print("Generating W3C conformance tests (XML 1.0 + Namespaces 1.0)...")

    # Start quick-xml reference tool
    has_quickxml = quickxml.start()
    if has_quickxml:
        print("Using quick-xml as reference implementation")
    else:
        print("Warning: Generating tests without expected values")
        print("Run 'moon test --update' to populate snapshots")

    all_tests = []

    # 1. xmltest (James Clark XML 1.0 tests)
    xmltest_manifest = XMLCONF_DIR / "xmltest" / "xmltest.xml"
    if xmltest_manifest.exists():
        tests = parse_test_manifest(xmltest_manifest, XMLCONF_DIR / "xmltest")
        print(f"  xmltest: {len(tests)} tests")
        all_tests.extend(tests)

    # 2. Namespaces 1.0 tests
    ns10_manifest = XMLCONF_DIR / "eduni" / "namespaces" / "1.0" / "rmt-ns10.xml"
    if ns10_manifest.exists():
        tests = parse_test_manifest(ns10_manifest, XMLCONF_DIR / "eduni" / "namespaces" / "1.0")
        print(f"  namespaces 1.0: {len(tests)} tests")
        all_tests.extend(tests)

    # 3. Sun tests (additional XML 1.0)
    for sun_file in ["sun-valid.xml", "sun-not-wf.xml"]:
        sun_manifest = XMLCONF_DIR / "sun" / sun_file
        if sun_manifest.exists():
            tests = parse_test_manifest(sun_manifest, XMLCONF_DIR / "sun")
            print(f"  sun/{sun_file}: {len(tests)} tests")
            all_tests.extend(tests)

    # 4. Errata tests (XML 1.0 errata editions)
    errata_dirs = [
        ("eduni/errata-2e", "errata2e.xml"),
        ("eduni/errata-3e", "errata3e.xml"),
        ("eduni/errata-4e", "errata4e.xml"),
    ]
    for errata_dir, manifest_name in errata_dirs:
        manifest = XMLCONF_DIR / errata_dir / manifest_name
        if manifest.exists():
            tests = parse_test_manifest(manifest, XMLCONF_DIR / errata_dir)
            print(f"  {errata_dir}: {len(tests)} tests")
            all_tests.extend(tests)

    # 5. Misc tests
    misc_manifest = XMLCONF_DIR / "eduni" / "misc" / "ht-bh.xml"
    if misc_manifest.exists():
        tests = parse_test_manifest(misc_manifest, XMLCONF_DIR / "eduni" / "misc")
        print(f"  eduni/misc: {len(tests)} tests")
        all_tests.extend(tests)

    print(f"\nTotal tests found: {len(all_tests)}")

    output_lines = [LICENSE_HEADER]
    valid_count = 0
    not_wf_count = 0
    skipped = 0

    for test_id, test_type, file_path, description in all_tests:
        content = load_test_file(file_path)
        if content is None:
            skipped += 1
            continue

        # Skip very large files (>50KB)
        if len(content) > 50000:
            skipped += 1
            continue

        # Skip files with external entity references (SYSTEM/PUBLIC)
        if '<!ENTITY' in content and ('SYSTEM' in content or 'PUBLIC' in content):
            skipped += 1
            continue

        # Skip XML 1.1 documents (we only support XML 1.0)
        if 'version="1.1"' in content or "version='1.1'" in content:
            skipped += 1
            continue

        if test_type == "valid":
            # Normalize line endings before parsing (XML spec requires \r\n -> \n)
            normalized_content = content.replace('\r\n', '\n').replace('\r', '\n')
            if has_quickxml:
                expected = quickxml.parse(normalized_content)
            else:
                expected = None
            output_lines.append(generate_valid_test(test_id, content, description, expected))
            valid_count += 1
        elif test_type == "not-wf":
            # Normalize line endings
            normalized_content = content.replace('\r\n', '\n').replace('\r', '\n')
            if has_quickxml:
                expected = quickxml.parse(normalized_content)
                # Check if quick-xml produced an error
                quickxml_errors = expected and "Error(" in expected
            else:
                expected = None
                quickxml_errors = True  # Assume error if no quick-xml
            output_lines.append(generate_not_wf_test(test_id, content, description, quickxml_errors, expected))
            not_wf_count += 1
        # Skip "invalid" and "error" types (DTD validation)

    quickxml.stop()

    OUTPUT_FILE.write_text(''.join(output_lines), encoding='utf-8')

    print(f"\nGenerated: {valid_count} valid + {not_wf_count} not-wf = {valid_count + not_wf_count} tests")
    print(f"Skipped: {skipped} (external entities, large files, DTD validation)")
    print(f"Output: {OUTPUT_FILE}")

if __name__ == "__main__":
    main()
